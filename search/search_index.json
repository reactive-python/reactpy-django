{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Django IDOM \u00b7 \u00b6 ReactJS for Django Developers. \u00b6 Django-IDOM connects your Python project to a ReactJS frontend, allowing you to create interactive websites without needing JavaScript! Following ReactJS styling, web elements are combined into reusable \"components\" . These components can utilize hooks and events to create infinitely complex web pages. When needed, IDOM can use components directly from NPM . For additional flexibility, components can also be fully developed in JavaScript . Any Python web framework with Websockets can support IDOM. See below for what frameworks are supported out of the box. Supported Frameworks Supported Frameworks (External) Flask , FastAPI , Sanic , Tornado Django , Plotly-Dash , Jupyter Resources \u00b6 Follow the links below to find out more about this project. Try it Now - Check out IDOM in a Jupyter Notebook. Documentation - Learn how to install, run, and use IDOM. Community Forum - Ask questions, share ideas, and show off projects.","title":"Home"},{"location":"#django-idom","text":"","title":"Django IDOM &middot;"},{"location":"#reactjs-for-django-developers","text":"Django-IDOM connects your Python project to a ReactJS frontend, allowing you to create interactive websites without needing JavaScript! Following ReactJS styling, web elements are combined into reusable \"components\" . These components can utilize hooks and events to create infinitely complex web pages. When needed, IDOM can use components directly from NPM . For additional flexibility, components can also be fully developed in JavaScript . Any Python web framework with Websockets can support IDOM. See below for what frameworks are supported out of the box. Supported Frameworks Supported Frameworks (External) Flask , FastAPI , Sanic , Tornado Django , Plotly-Dash , Jupyter","title":"ReactJS for Django Developers."},{"location":"#resources","text":"Follow the links below to find out more about this project. Try it Now - Check out IDOM in a Jupyter Notebook. Documentation - Learn how to install, run, and use IDOM. Community Forum - Ask questions, share ideas, and show off projects.","title":"Resources"},{"location":"changelog/","text":"Attribution The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . Unreleased \u00b6 Added \u00b6 auth_required decorator to prevent your components from rendering to unauthenticated users. use_query hook for fetching database values. use_mutation hook for modifying database values. view_to_component utility to convert legacy Django views to IDOM components. Changed \u00b6 Bumped the minimum IDOM version to 0.40.2 Fixed \u00b6 IDOM preloader is no longer sensitive to whitespace within template tags. 1.1.0 - 2022-07-01 \u00b6 Added \u00b6 django_css and django_js components to defer loading CSS & JS files until needed. Changed \u00b6 Bumped the minimum IDOM version to 0.39.0 1.0.0 - 2022-05-22 \u00b6 Added \u00b6 Django-specific hooks! use_websocket , use_scope , and use_location are now available within the django_idom.hooks module. Documentation has been placed into a formal docs webpage. Logging for when a component fails to import, or if no components were found within Django. Changed \u00b6 idom_component template tag has been renamed to component Bumped the minimum IDOM version to 0.38.0 Removed \u00b6 websocket parameter for components has been removed. Functionally, it is replaced with django_idom.hooks.use_websocket . 0.0.5 - 2022-04-04 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.37.2 Fixed \u00b6 ModuleNotFoundError: No module named idom.core.proto caused by IDOM 0.37.2 0.0.4 - 2022-03-05 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.37.1 0.0.3 - 2022-02-19 \u00b6 Changed \u00b6 Bumped the minimum IDOM version to 0.36.3 0.0.2 - 2022-01-30 \u00b6 Added \u00b6 Ability to declare the HTML class of the top-level component div name = ... parameter to IDOM HTTP paths for use with django.urls.reverse() Cache versioning to automatically invalidate old web module files from the cache backend Automatic pre-population of the IDOM component registry Type hinting for IdomWebsocket Changed \u00b6 Fetching web modules from disk and/or cache is now fully async Static files are now contained within a django_idom/ parent folder Upgraded IDOM to version 0.36.0 Minimum Django version required is now 4.0 Minimum Python version required is now 3.8 Removed \u00b6 IDOM_WEB_MODULES_PATH has been replaced with Django include(...) IDOM_WS_MAX_RECONNECT_DELAY has been renamed to IDOM_WS_MAX_RECONNECT_TIMEOUT idom_web_modules cache backend has been renamed to idom Fixed \u00b6 Increase test timeout values to prevent false positives Windows compatibility for building Django-IDOM Security \u00b6 Fixed potential directory travesal attack on the IDOM web modules URL 0.0.1 - 2021-08-18 \u00b6 Added \u00b6 Support for IDOM within the Django","title":"Changelog"},{"location":"changelog/#unreleased","text":"","title":"Unreleased"},{"location":"changelog/#added","text":"auth_required decorator to prevent your components from rendering to unauthenticated users. use_query hook for fetching database values. use_mutation hook for modifying database values. view_to_component utility to convert legacy Django views to IDOM components.","title":"Added"},{"location":"changelog/#changed","text":"Bumped the minimum IDOM version to 0.40.2","title":"Changed"},{"location":"changelog/#fixed","text":"IDOM preloader is no longer sensitive to whitespace within template tags.","title":"Fixed"},{"location":"changelog/#110-2022-07-01","text":"","title":"1.1.0 - 2022-07-01"},{"location":"changelog/#added_1","text":"django_css and django_js components to defer loading CSS & JS files until needed.","title":"Added"},{"location":"changelog/#changed_1","text":"Bumped the minimum IDOM version to 0.39.0","title":"Changed"},{"location":"changelog/#100-2022-05-22","text":"","title":"1.0.0 - 2022-05-22"},{"location":"changelog/#added_2","text":"Django-specific hooks! use_websocket , use_scope , and use_location are now available within the django_idom.hooks module. Documentation has been placed into a formal docs webpage. Logging for when a component fails to import, or if no components were found within Django.","title":"Added"},{"location":"changelog/#changed_2","text":"idom_component template tag has been renamed to component Bumped the minimum IDOM version to 0.38.0","title":"Changed"},{"location":"changelog/#removed","text":"websocket parameter for components has been removed. Functionally, it is replaced with django_idom.hooks.use_websocket .","title":"Removed"},{"location":"changelog/#005-2022-04-04","text":"","title":"0.0.5 - 2022-04-04"},{"location":"changelog/#changed_3","text":"Bumped the minimum IDOM version to 0.37.2","title":"Changed"},{"location":"changelog/#fixed_1","text":"ModuleNotFoundError: No module named idom.core.proto caused by IDOM 0.37.2","title":"Fixed"},{"location":"changelog/#004-2022-03-05","text":"","title":"0.0.4 - 2022-03-05"},{"location":"changelog/#changed_4","text":"Bumped the minimum IDOM version to 0.37.1","title":"Changed"},{"location":"changelog/#003-2022-02-19","text":"","title":"0.0.3 - 2022-02-19"},{"location":"changelog/#changed_5","text":"Bumped the minimum IDOM version to 0.36.3","title":"Changed"},{"location":"changelog/#002-2022-01-30","text":"","title":"0.0.2 - 2022-01-30"},{"location":"changelog/#added_3","text":"Ability to declare the HTML class of the top-level component div name = ... parameter to IDOM HTTP paths for use with django.urls.reverse() Cache versioning to automatically invalidate old web module files from the cache backend Automatic pre-population of the IDOM component registry Type hinting for IdomWebsocket","title":"Added"},{"location":"changelog/#changed_6","text":"Fetching web modules from disk and/or cache is now fully async Static files are now contained within a django_idom/ parent folder Upgraded IDOM to version 0.36.0 Minimum Django version required is now 4.0 Minimum Python version required is now 3.8","title":"Changed"},{"location":"changelog/#removed_1","text":"IDOM_WEB_MODULES_PATH has been replaced with Django include(...) IDOM_WS_MAX_RECONNECT_DELAY has been renamed to IDOM_WS_MAX_RECONNECT_TIMEOUT idom_web_modules cache backend has been renamed to idom","title":"Removed"},{"location":"changelog/#fixed_2","text":"Increase test timeout values to prevent false positives Windows compatibility for building Django-IDOM","title":"Fixed"},{"location":"changelog/#security","text":"Fixed potential directory travesal attack on the IDOM web modules URL","title":"Security"},{"location":"changelog/#001-2021-08-18","text":"","title":"0.0.1 - 2021-08-18"},{"location":"changelog/#added_4","text":"Support for IDOM within the Django","title":"Added"},{"location":"contribute/django-idom/","text":"Looking to contribute features that are not Django specific? Everything within the django-idom repository must be specific to Django integration. Check out the IDOM Core documentation to contribute general features such as: components, hooks, events, and more. If you plan to make code changes to this repository, you'll need to install the following dependencies first: Python 3.8+ Git NPM for installing and managing Javascript ChromeDriver for testing with Selenium Once done, you should clone this repository: git clone https://github.com/idom-team/django-idom.git cd django-idom Then, by running the command below you can: Install an editable version of the Python code Download, build, and install Javascript dependencies pip install -e . -r requirements.txt Finally, to verify that everything is working properly, you can manually run the development webserver. cd tests python manage.py runserver Navigate to http://127.0.0.1:8000 to see if the tests are rendering correctly.","title":"Code"},{"location":"contribute/docs/","text":"If you plan to make changes to this documentation, you'll need to install the following dependencies first: Python 3.8+ Git Once done, you should clone this repository: git clone https://github.com/idom-team/django-idom.git cd django-idom Then, by running the command below you can: Install an editable version of the documentation Self-host a test server for the documentation pip install -r ./requirements/build-docs.txt --upgrade Finally, to verify that everything is working properly, you can manually run the docs preview webserver. mkdocs serve Navigate to http://127.0.0.1:8000 to view a preview of the documentation.","title":"Docs"},{"location":"contribute/running-tests/","text":"This repo uses Nox to run scripts which can be found in noxfile.py . For a full test of available scripts run nox -l . To run the full test suite simple execute: nox -s test If you do not want to run the tests in the background: nox -s test -- --headed Most tests will not run on Windows Due to bugs within Django Channels , functional tests are not run on Windows. In order for Windows users to test Django-IDOM functionality, you will need to run tests via Windows Subsystem for Linux .","title":"Running Tests"},{"location":"features/components/","text":"View To Component \u00b6 Convert any Django view into a IDOM component by usng this decorator. Compatible with sync/async Function Based Views and Class Based Views . components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) See Interface Parameters Name Type Description Default view Callable | View The view function or class to convert. N/A compatibility bool If True, the component will be rendered in an iframe. Strict parsing does not apply to compatibility mode. False transforms Iterable[Callable[[VdomDict], Any]] A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. tuple strict_parsing bool If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. True request HttpRequest | None Request object to provide to the view. Custom request objects cannot be used in compatibility mode. None args Iterable The positional arguments to pass to the view. tuple kwargs Dict | None The keyword arguments to pass to the view. None Returns Type Description Component An IDOM component. None No component render. How do I use this for Class Based Views? You can simply pass your Class Based View directly into this function. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import HelloWorldView @component def my_component (): return html . div ( view_to_component ( HelloWorldView ), ) from django.http import HttpResponse from django.views import View class HelloWorldView ( View ): def get ( self , request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) How do I pass arguments into the view? You can use the args and kwargs parameters to pass arguments to the view. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , args = [ \"value_1\" , \"value_2\" ], kwargs = { \"key_1\" : \"value_1\" , \"key_2\" : \"value_2\" }, ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) What is compatibility mode? For views that rely on HTTP responses other than GET (such as PUT , POST , PATCH , etc), you should consider using compatibility mode to render your view within an iframe. Any view can be rendered within compatibility mode. However, the strict_parsing argument does not apply to compatibility mode. Please note that by default the iframe is unstyled, and thus won't look pretty until you add some CSS. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , compatibility = True ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) What is strict_parsing ? By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5. However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as < my-tag > Hello World </ my-tag > . In these scenarios, you may want to rely on best-fit parsing by setting the strict_parsing parameter to False . components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , strict_parsing = False ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) Note that best-fit parsing is very similar to how web browsers will handle broken HTML. What is transforms ? After your view has been turned into VDOM (python dictionaries), view_to_component will call your transforms functions on every VDOM node. This allows you to modify your view prior to rendering. For example, if you are trying to modify the text of a node with a certain id , you can create a transform like such: components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view def example_transform ( vdom ): attributes = vdom . get ( \"attributes\" ) if attributes and attributes . get ( \"id\" ) == \"hello-world\" : vdom [ \"children\" ][ 0 ] = \"Good Bye World!\" @component def my_component (): return view_to_component ( hello_world_view , transforms = [ example_transform ], ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"<div id='hello-world'> Hello World! <div>\" ) Django CSS \u00b6 Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files . components.py from idom import component , html from django_idom.components import django_css @component def my_component (): return html . div ( django_css ( \"css/buttons.css\" ), html . button ( \"My Button!\" ), ) Should I put django_css at the top of my component? Yes, if the stylesheet contains styling for your component. Can I load static CSS using html.link instead? While you can load stylesheets with html.link , keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause some visual jankiness, so use this at your own discretion. Here's an example on what you should avoid doing for Django static files: from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : static ( \"css/buttons.css\" )}), html . button ( \"My Button!\" ), ) How do I load external CSS? django_css can only be used with local static files. For external CSS, substitute django_css with html.link . from idom import component , html @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : \"https://example.com/external-styles.css\" }), html . button ( \"My Button!\" ), ) Why not load my CSS in < head > ? Traditionally, stylesheets are loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_css component to defer loading your stylesheet until it is needed. Django JS \u00b6 Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files . components.py from idom import component , html from django_idom.components import django_js @component def my_component (): return html . div ( html . button ( \"My Button!\" ), django_js ( \"js/scripts.js\" ), ) Should I put django_js at the bottom of my component? Yes, if your scripts are reliant on the contents of the component. Can I load static JavaScript using html.script instead? While you can load JavaScript with html.script , keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed. Here's an example on what you should avoid doing for Django static files: from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . script ({ \"src\" : static ( \"js/scripts.js\" )}), html . button ( \"My Button!\" ), ) How do I load external JS? django_js can only be used with local static files. For external JavaScript, substitute django_js with html.script . from idom import component , html @component def my_component (): return html . div ( html . script ({ \"src\" : \"https://example.com/external-scripts.js\" }), html . button ( \"My Button!\" ), ) Why not load my JS in < head > ? Traditionally, JavaScript is loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_js component to defer loading your JavaScript until it is needed.","title":"Components"},{"location":"features/components/#view-to-component","text":"Convert any Django view into a IDOM component by usng this decorator. Compatible with sync/async Function Based Views and Class Based Views . components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) See Interface Parameters Name Type Description Default view Callable | View The view function or class to convert. N/A compatibility bool If True, the component will be rendered in an iframe. Strict parsing does not apply to compatibility mode. False transforms Iterable[Callable[[VdomDict], Any]] A list of functions that transforms the newly generated VDOM. The functions will be called on each VDOM node. tuple strict_parsing bool If True, an exception will be generated if the HTML does not perfectly adhere to HTML5. True request HttpRequest | None Request object to provide to the view. Custom request objects cannot be used in compatibility mode. None args Iterable The positional arguments to pass to the view. tuple kwargs Dict | None The keyword arguments to pass to the view. None Returns Type Description Component An IDOM component. None No component render. How do I use this for Class Based Views? You can simply pass your Class Based View directly into this function. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import HelloWorldView @component def my_component (): return html . div ( view_to_component ( HelloWorldView ), ) from django.http import HttpResponse from django.views import View class HelloWorldView ( View ): def get ( self , request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) How do I pass arguments into the view? You can use the args and kwargs parameters to pass arguments to the view. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , args = [ \"value_1\" , \"value_2\" ], kwargs = { \"key_1\" : \"value_1\" , \"key_2\" : \"value_2\" }, ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) What is compatibility mode? For views that rely on HTTP responses other than GET (such as PUT , POST , PATCH , etc), you should consider using compatibility mode to render your view within an iframe. Any view can be rendered within compatibility mode. However, the strict_parsing argument does not apply to compatibility mode. Please note that by default the iframe is unstyled, and thus won't look pretty until you add some CSS. components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , compatibility = True ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) What is strict_parsing ? By default, an exception will be generated if your view's HTML does not perfectly adhere to HTML5. However, there are some circumstances where you may not have control over the original HTML, so you may be unable to fix it. Or you may be relying on non-standard HTML tags such as < my-tag > Hello World </ my-tag > . In these scenarios, you may want to rely on best-fit parsing by setting the strict_parsing parameter to False . components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view @component def my_component (): return html . div ( view_to_component ( hello_world_view , strict_parsing = False ), ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"Hello World!\" ) Note that best-fit parsing is very similar to how web browsers will handle broken HTML. What is transforms ? After your view has been turned into VDOM (python dictionaries), view_to_component will call your transforms functions on every VDOM node. This allows you to modify your view prior to rendering. For example, if you are trying to modify the text of a node with a certain id , you can create a transform like such: components.py views.py from idom import component , html from django_idom.components import view_to_component from .views import hello_world_view def example_transform ( vdom ): attributes = vdom . get ( \"attributes\" ) if attributes and attributes . get ( \"id\" ) == \"hello-world\" : vdom [ \"children\" ][ 0 ] = \"Good Bye World!\" @component def my_component (): return view_to_component ( hello_world_view , transforms = [ example_transform ], ) from django.http import HttpResponse def hello_world_view ( request , * args , ** kwargs ): return HttpResponse ( \"<div id='hello-world'> Hello World! <div>\" )","title":"View To Component"},{"location":"features/components/#django-css","text":"Allows you to defer loading a CSS stylesheet until a component begins rendering. This stylesheet must be stored within Django's static files . components.py from idom import component , html from django_idom.components import django_css @component def my_component (): return html . div ( django_css ( \"css/buttons.css\" ), html . button ( \"My Button!\" ), ) Should I put django_css at the top of my component? Yes, if the stylesheet contains styling for your component. Can I load static CSS using html.link instead? While you can load stylesheets with html.link , keep in mind that loading this way does not ensure load order. Thus, your stylesheet will be loaded after your component is displayed. This would likely cause some visual jankiness, so use this at your own discretion. Here's an example on what you should avoid doing for Django static files: from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : static ( \"css/buttons.css\" )}), html . button ( \"My Button!\" ), ) How do I load external CSS? django_css can only be used with local static files. For external CSS, substitute django_css with html.link . from idom import component , html @component def my_component (): return html . div ( html . link ({ \"rel\" : \"stylesheet\" , \"href\" : \"https://example.com/external-styles.css\" }), html . button ( \"My Button!\" ), ) Why not load my CSS in < head > ? Traditionally, stylesheets are loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_css component to defer loading your stylesheet until it is needed.","title":"Django CSS"},{"location":"features/components/#django-js","text":"Allows you to defer loading JavaScript until a component begins rendering. This JavaScript must be stored within Django's static files . components.py from idom import component , html from django_idom.components import django_js @component def my_component (): return html . div ( html . button ( \"My Button!\" ), django_js ( \"js/scripts.js\" ), ) Should I put django_js at the bottom of my component? Yes, if your scripts are reliant on the contents of the component. Can I load static JavaScript using html.script instead? While you can load JavaScript with html.script , keep in mind that loading this way does not ensure load order. Thus, your JavaScript will likely be loaded at an arbitrary time after your component is displayed. Here's an example on what you should avoid doing for Django static files: from idom import component , html from django.templatetags.static import static @component def my_component (): return html . div ( html . script ({ \"src\" : static ( \"js/scripts.js\" )}), html . button ( \"My Button!\" ), ) How do I load external JS? django_js can only be used with local static files. For external JavaScript, substitute django_js with html.script . from idom import component , html @component def my_component (): return html . div ( html . script ({ \"src\" : \"https://example.com/external-scripts.js\" }), html . button ( \"My Button!\" ), ) Why not load my JS in < head > ? Traditionally, JavaScript is loaded in your < head > using the {% load static %} template tag. To help improve webpage load times, you can use the django_js component to defer loading your JavaScript until it is needed.","title":"Django JS"},{"location":"features/decorators/","text":"Auth Required \u00b6 You can limit access to a component to users with a specific auth_attribute by using this decorator. By default, this decorator checks if the user is logged in, and his/her account has not been deactivated. Common uses of this decorator are to hide components from AnonymousUser , or render a component only if the user is_staff or is_superuser . This decorator can be used with or without parentheses. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required def my_component (): return html . div ( \"I am logged in!\" ) See Interface Parameters Name Type Description Default auth_attribute str The value to check within the user object. This is checked in the form of UserModel.<auth_attribute> . \"is_active\" fallback ComponentType , VdomDict , None The component or idom.html snippet to render if the user is not authenticated. None Returns Type Description Component An IDOM component. VdomDict An idom.html snippet. None No component render. How do I render a different component if authentication fails? You can use a component with the fallback argument, as seen below. components.py from django_idom.decorators import auth_required from idom import component , html @component def my_component_fallback (): return html . div ( \"I am NOT logged in!\" ) @component @auth_required ( fallback = my_component_fallback ) def my_component (): return html . div ( \"I am logged in!\" ) How do I render a simple idom.html snippet if authentication fails? You can use a idom.html snippet with the fallback argument, as seen below. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( fallback = html . div ( \"I am NOT logged in!\" )) def my_component (): return html . div ( \"I am logged in!\" ) How can I check if a user is_staff ? You can set the auth_attribute to is_staff , as seen blow. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_staff\" ) def my_component (): return html . div ( \"I am logged in!\" ) How can I check for a custom attribute? You will need to be using a custom user model within your Django instance. For example, if your user model has the field is_really_cool ... from django.contrib.auth.models import AbstractBaseUser class CustomUserModel ( AbstractBaseUser ): @property def is_really_cool ( self ): return True ... then you would do the following within your decorator: components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_really_cool\" ) def my_component (): return html . div ( \"I am logged in!\" )","title":"Decorators"},{"location":"features/decorators/#auth-required","text":"You can limit access to a component to users with a specific auth_attribute by using this decorator. By default, this decorator checks if the user is logged in, and his/her account has not been deactivated. Common uses of this decorator are to hide components from AnonymousUser , or render a component only if the user is_staff or is_superuser . This decorator can be used with or without parentheses. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required def my_component (): return html . div ( \"I am logged in!\" ) See Interface Parameters Name Type Description Default auth_attribute str The value to check within the user object. This is checked in the form of UserModel.<auth_attribute> . \"is_active\" fallback ComponentType , VdomDict , None The component or idom.html snippet to render if the user is not authenticated. None Returns Type Description Component An IDOM component. VdomDict An idom.html snippet. None No component render. How do I render a different component if authentication fails? You can use a component with the fallback argument, as seen below. components.py from django_idom.decorators import auth_required from idom import component , html @component def my_component_fallback (): return html . div ( \"I am NOT logged in!\" ) @component @auth_required ( fallback = my_component_fallback ) def my_component (): return html . div ( \"I am logged in!\" ) How do I render a simple idom.html snippet if authentication fails? You can use a idom.html snippet with the fallback argument, as seen below. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( fallback = html . div ( \"I am NOT logged in!\" )) def my_component (): return html . div ( \"I am logged in!\" ) How can I check if a user is_staff ? You can set the auth_attribute to is_staff , as seen blow. components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_staff\" ) def my_component (): return html . div ( \"I am logged in!\" ) How can I check for a custom attribute? You will need to be using a custom user model within your Django instance. For example, if your user model has the field is_really_cool ... from django.contrib.auth.models import AbstractBaseUser class CustomUserModel ( AbstractBaseUser ): @property def is_really_cool ( self ): return True ... then you would do the following within your decorator: components.py from django_idom.decorators import auth_required from django_idom.hooks import use_websocket from idom import component , html @component @auth_required ( auth_attribute = \"is_really_cool\" ) def my_component (): return html . div ( \"I am logged in!\" )","title":"Auth Required"},{"location":"features/hooks/","text":"Looking for more hooks? Check out the IDOM Core docs on hooks! Use Query \u00b6 The use_query hook is used fetch Django ORM queries. components.py models.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_query def get_items (): return TodoItem . objects . all () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) return rendered_items from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django with a natively asynchronous ORM. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information. Use Mutation \u00b6 The use_mutation hook is used to modify Django ORM objects. components.py models.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can use_mutation trigger a refetch of use_query ? Yes, use_mutation can queue a refetch of a use_query via the refetch=... argument. The example below is a merge of the use_query and use_mutation examples above with the addition of a refetch argument on use_mutation . Please note that any use_query hooks that use get_items will be refetched upon a successful mutation. components.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def get_items (): return TodoItem . objects . all () def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) item_mutation = use_mutation ( add_item , refetch = get_items ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , rendered_items , ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django with a natively asynchronous ORM. However, even when resolved it is best practice to perform ORM queries within the use_query in order to handle loading and error states. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information. Use Websocket \u00b6 You can fetch the Django Channels websocket at any time by using use_websocket . components.py from idom import component , html from django_idom.hooks import use_websocket @component def my_component (): my_websocket = use_websocket () return html . div ( my_websocket ) Use Scope \u00b6 This is a shortcut that returns the Websocket's scope . components.py from idom import component , html from django_idom.hooks import use_scope @component def my_component (): my_scope = use_scope () return html . div ( my_scope ) Use Location \u00b6 This hook's behavior will be changed in a future update This hook will be updated to return the browser's current URL. This change will come in alongside IDOM URL routing support. Check out idom-team/idom#569 for more information. This is a shortcut that returns the Websocket's path . components.py from idom import component , html from django_idom.hooks import use_location @component def my_component (): my_location = use_location () return html . div ( my_location )","title":"Hooks"},{"location":"features/hooks/#use-query","text":"The use_query hook is used fetch Django ORM queries. components.py models.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_query def get_items (): return TodoItem . objects . all () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) return rendered_items from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django with a natively asynchronous ORM. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information.","title":"Use Query"},{"location":"features/hooks/#use-mutation","text":"The use_mutation hook is used to modify Django ORM objects. components.py models.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): item_mutation = use_mutation ( add_item ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , ) from django.db import models class TodoItem ( models . Model ): text = models . CharField ( max_length = 255 ) Can use_mutation trigger a refetch of use_query ? Yes, use_mutation can queue a refetch of a use_query via the refetch=... argument. The example below is a merge of the use_query and use_mutation examples above with the addition of a refetch argument on use_mutation . Please note that any use_query hooks that use get_items will be refetched upon a successful mutation. components.py from example_project.my_app.models import TodoItem from idom import component , html from django_idom.hooks import use_mutation def get_items (): return TodoItem . objects . all () def add_item ( text : str ): TodoItem ( text = text ) . save () @component def todo_list (): item_query = use_query ( get_items ) if item_query . loading : rendered_items = html . h2 ( \"Loading...\" ) elif item_query . error : rendered_items = html . h2 ( \"Error when loading!\" ) else : rendered_items = html . ul ( html . li ( item , key = item ) for item in item_query . data ) item_mutation = use_mutation ( add_item , refetch = get_items ) if item_mutation . loading : mutation_status = html . h2 ( \"Adding...\" ) elif item_mutation . error : mutation_status = html . h2 ( \"Error when adding!\" ) else : mutation_status = \"\" def submit_event ( event ): if event [ \"key\" ] == \"Enter\" : item_mutation . execute ( text = event [ \"target\" ][ \"value\" ]) return html . div ( html . label ( \"Add an item:\" ), html . input ({ \"type\" : \"text\" , \"onKeyDown\" : submit_event }), mutation_status , rendered_items , ) Can I make ORM calls without hooks? Due to Django's ORM design, database queries must be deferred using hooks. Otherwise, you will see a SynchronousOnlyOperation exception. This may be resolved in a future version of Django with a natively asynchronous ORM. However, even when resolved it is best practice to perform ORM queries within the use_query in order to handle loading and error states. What is an \"ORM\"? A Python Object Relational Mapper is an API for your code to access a database. See the Django ORM documentation for more information.","title":"Use Mutation"},{"location":"features/hooks/#use-websocket","text":"You can fetch the Django Channels websocket at any time by using use_websocket . components.py from idom import component , html from django_idom.hooks import use_websocket @component def my_component (): my_websocket = use_websocket () return html . div ( my_websocket )","title":"Use Websocket"},{"location":"features/hooks/#use-scope","text":"This is a shortcut that returns the Websocket's scope . components.py from idom import component , html from django_idom.hooks import use_scope @component def my_component (): my_scope = use_scope () return html . div ( my_scope )","title":"Use Scope"},{"location":"features/hooks/#use-location","text":"This hook's behavior will be changed in a future update This hook will be updated to return the browser's current URL. This change will come in alongside IDOM URL routing support. Check out idom-team/idom#569 for more information. This is a shortcut that returns the Websocket's path . components.py from idom import component , html from django_idom.hooks import use_location @component def my_component (): my_location = use_location () return html . div ( my_location )","title":"Use Location"},{"location":"features/settings/","text":"Django IDOM uses your Django project's settings.py file to modify some behaviors of IDOM. Here are the configurable variables that are available. settings.py # If \"idom\" cache is not configured, then we'll use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\" Do I need to modify my settings? The default configuration of IDOM is adequate for the majority of use cases. You should only consider changing settings when the necessity arises.","title":"Settings"},{"location":"features/templatetag/","text":"Integrated within Django IDOM, we bundle a template tag. Within this tag, you can pass in keyword arguments directly into your component. my-template.html {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Do not use context variables for the IDOM component name Our pre-processor relies on the template tag containing a string. Do not use a Django context variable for the path string. Failure to follow this warning will result in a performance penalty and also jankiness when using the Django autoreloader. For example, do not do the following: views.py def example_view (): context_vars = { \"dont_do_this\" : \"example_project.my_app.components.hello_world\" } return render ( request , \"my-template.html\" , context_vars ) my-template.html <!-- This is bad --> {% component dont_do_this recipient = \"World\" %} <!-- This is good --> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} Reserved keyword arguments: class and key For this template tag, there are two reserved keyword arguments: class and key class allows you to apply a HTML class to the top-level component div. This is useful for styling purposes. key allows you to force the component to use a specific key value . You typically won't need to set this. my-template.html ... {% component \"example.components.my_component\" class = \"my-html-class\" key = 123 %} ... Can I use multiple components on one page? You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page. {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} {% component \"example_project.my_app_2.components.class_component\" class = \"bold small-font\" %} <div> {% component \"example_project.my_app_3.components.simple_component\" %} </div> </body> </html> But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your < body > tag. Additionally, the components in the example above will not be able to interact with each other, except through database queries. Can I use positional arguments instead of keyword arguments? You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time. What is a \"template tag\"? You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django IDOM uses a {% component ... %} template tag to perform it's magic. Keep in mind, in order to use the {% component ... %} tag, you'll need to first call {% load idom %} to gain access to it. my-template.html {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html>","title":"Template Tag"},{"location":"getting-started/create-component/","text":"Summary Create a component function using our decorator. You'll need a file to define your IDOM components. We recommend creating a components.py file within your chosen Django app to start out. Within this file, we will create a simple hello_world component. components.py from idom import component , html @component def hello_world ( recipient : str ): return html . h1 ( f \"Hello { recipient } !\" ) What should I name my IDOM files and functions? You have full freedom in naming/placement of your files and functions. You should determine the best way to sort your Python modules and component functions to fit your needs. Ultimately, components are referenced by Python dotted path in my-template.html ( see next step ). So, at minimum this path needs to be valid to Python's importlib .","title":"2. Create a Component"},{"location":"getting-started/initial-steps/","text":"Summary Set up a Django Project with at least one app. If you've reached this point, you should have already installed Django-IDOM through the previous steps. For the examples within this section, we will assume you've placed the files generated by startapp directly into your Django project folder. This is common for small projects. How do I organize my Django project for IDOM? Django-IDOM has no project structure requirements. Organize everything as you wish, just like any Django project . I've never used Django, what do I need to learn? These docs assumes you have created a basic Django project , which involves creating and installing at least one Django app . If not, check out this 9 minute YouTube tutorial created by IDG TECHtalk . Afterwards, make sure to follow the Django-IDOM installation instructions .","title":"1. Initial Steps"},{"location":"getting-started/learn-more/","text":"Congratulations \u00b6 If you followed the previous steps, you've now created a \"Hello World\" component! The docs you are reading only covers our Django integration. To learn more about features, such as interactive events and hooks, check out the IDOM Core Documentation ! Additionally, the vast majority of tutorials/guides you find for React can be applied to IDOM. Learn More Django-IDOM Exclusive Features IDOM Hooks, Events, and More Ask Questions on GitHub Discussions","title":"5. Learn More"},{"location":"getting-started/learn-more/#congratulations","text":"If you followed the previous steps, you've now created a \"Hello World\" component! The docs you are reading only covers our Django integration. To learn more about features, such as interactive events and hooks, check out the IDOM Core Documentation ! Additionally, the vast majority of tutorials/guides you find for React can be applied to IDOM. Learn More Django-IDOM Exclusive Features IDOM Hooks, Events, and More Ask Questions on GitHub Discussions","title":"Congratulations"},{"location":"getting-started/reference-component/","text":"Summary Decide where the component will be displayed by using our template tag. In your Django app 's HTML template, you can now embed your IDOM component using the component template tag. Within this tag, you will need to type in your dotted path to the component function as the first argument. Additonally, you can pass in keyword arguments into your component function. For example, after reading the code below, pay attention to how the function definition for hello_world ( in the previous example ) accepts a recipient argument. my-template.html {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Do not use context variables for the IDOM component name Our pre-processor relies on the template tag containing a string. Do not use a Django context variable for the path string. Failure to follow this warning will result in a performance penalty and also jankiness when using the Django autoreloader. For example, do not do the following: views.py def example_view (): context_vars = { \"dont_do_this\" : \"example_project.my_app.components.hello_world\" } return render ( request , \"my-template.html\" , context_vars ) my-template.html <!-- This is bad --> {% component dont_do_this recipient = \"World\" %} <!-- This is good --> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} Reserved keyword arguments: class and key For this template tag, there are two reserved keyword arguments: class and key class allows you to apply a HTML class to the top-level component div. This is useful for styling purposes. key allows you to force the component to use a specific key value . You typically won't need to set this. my-template.html ... {% component \"example.components.my_component\" class = \"my-html-class\" key = 123 %} ... Can I use multiple components on one page? You can add as many components to a webpage as needed by using the template tag multiple times. Retrofitting legacy sites to use IDOM will typically involve many components on one page. {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} {% component \"example_project.my_app_2.components.class_component\" class = \"bold small-font\" %} <div> {% component \"example_project.my_app_3.components.simple_component\" %} </div> </body> </html> But keep in mind, in scenarios where you are trying to create a Single Page Application (SPA) within Django, you will only have one central component within your < body > tag. Additionally, the components in the example above will not be able to interact with each other, except through database queries. Can I use positional arguments instead of keyword arguments? You can only pass in keyword arguments within the template tag. Due to technical limitations, positional arguments are not supported at this time. What is a \"template tag\"? You can think of template tags as Django's way of allowing you to run Python code within your HTML. Django IDOM uses a {% component ... %} template tag to perform it's magic. Keep in mind, in order to use the {% component ... %} tag, you'll need to first call {% load idom %} to gain access to it. my-template.html {% load idom %} <!DOCTYPE html> <html> <body> {% component \"example_project.my_app.components.hello_world\" recipient = \"World\" %} </body> </html> Where is my templates folder? If you do not have a templates folder in your Django app , you can simply create one! Keep in mind, templates within this folder will not be detected by Django unless you add the corresponding Django app to settings.py:INSTALLED_APPS .","title":"3. Use the Template Tag"},{"location":"getting-started/render-view/","text":"Summary Select your template containing an IDOM component, and render it using a Django view. We will assume you've created a Django View before, but here's a simple example below. Within your Django app 's views.py file, you'll need to create a function to render the HTML template containing your IDOM components. In this example, we will create a view that renders my-template.html ( from the previous step ). views.py from django.shortcuts import render def index ( request ): return render ( request , \"my-template.html\" ) We will add this new view into your urls.py . urls.py from django.urls import path from example_project.my_app import views urlpatterns = [ path ( \"example/\" , views . index ), ] Now, navigate to http://127.0.0.1:8000/example/ . If you copy-pasted the component from the previous example, you will now see your component display \"Hello World\". Which urls.py do I add my views to? For simple Django projects , you can easily add all of your views directly into the Django project's urls.py . However, as you start increase your project's complexity you might end up with way too much within one file. Once you reach that point, we recommend creating an individual urls.py within each of your Django apps . Then, within your Django project's urls.py you will use Django's include function to link it all together.","title":"4. Render Your View"},{"location":"installation/","text":"Learning Django first is recommended! These docs assumes you have created a basic Django project , which involves creating and installing at least one Django app . If not, check out this 9 minute YouTube tutorial created by IDG TECHtalk . Install from PyPI \u00b6 pip install django-idom You'll also need to modify a few files in your Django project ... Configure settings.py \u00b6 In your settings you'll need to add django_idom to INSTALLED_APPS . settings.py INSTALLED_APPS = [ \"django_idom\" , ... ] Enable Django ASGI (Required) Django-IDOM requires ASGI in order to use Websockets. If you haven't enabled ASGI on your Django project yet, you'll need to add channels to INSTALLED_APPS and set your ASGI_APPLICATION variable. Read the Django Channels Docs for more info. settings.py INSTALLED_APPS = [ \"channels\" , ... ] ASGI_APPLICATION = \"example_project.asgi.application\" Configure IDOM settings (Optional) Below are a handful of values you can change within settings.py to modify the behavior of IDOM. settings.py # If \"idom\" cache is not configured, then we'll use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\" Configure urls.py \u00b6 Add IDOM HTTP paths to your urlpatterns . urls.py from django.urls import include , path urlpatterns = [ path ( \"idom/\" , include ( \"django_idom.http.urls\" )), ... ] Configure asgi.py \u00b6 Register IDOM's Websocket using IDOM_WEBSOCKET_PATH . asgi.py import os from django.core.asgi import get_asgi_application # Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name! os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"example_project.settings\" ) django_asgi_app = get_asgi_application () from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from channels.sessions import SessionMiddlewareStack from django_idom import IDOM_WEBSOCKET_PATH application = ProtocolTypeRouter ( { \"http\" : django_asgi_app , \"websocket\" : SessionMiddlewareStack ( AuthMiddlewareStack ( URLRouter ([ IDOM_WEBSOCKET_PATH ])) ), } ) Where is my asgi.py? If you do not have an asgi.py , follow the channels installation guide .","title":"Installation"},{"location":"installation/#install-from-pypi","text":"pip install django-idom You'll also need to modify a few files in your Django project ...","title":"Install from PyPI"},{"location":"installation/#configure-settingspy","text":"In your settings you'll need to add django_idom to INSTALLED_APPS . settings.py INSTALLED_APPS = [ \"django_idom\" , ... ] Enable Django ASGI (Required) Django-IDOM requires ASGI in order to use Websockets. If you haven't enabled ASGI on your Django project yet, you'll need to add channels to INSTALLED_APPS and set your ASGI_APPLICATION variable. Read the Django Channels Docs for more info. settings.py INSTALLED_APPS = [ \"channels\" , ... ] ASGI_APPLICATION = \"example_project.asgi.application\" Configure IDOM settings (Optional) Below are a handful of values you can change within settings.py to modify the behavior of IDOM. settings.py # If \"idom\" cache is not configured, then we'll use \"default\" instead CACHES = { \"idom\" : { \"BACKEND\" : ... }, } # Maximum seconds between two reconnection attempts that would cause the client give up. # 0 will disable reconnection. IDOM_WS_MAX_RECONNECT_TIMEOUT = 604800 # The URL for IDOM to serve websockets IDOM_WEBSOCKET_URL = \"idom/\"","title":"Configure settings.py"},{"location":"installation/#configure-urlspy","text":"Add IDOM HTTP paths to your urlpatterns . urls.py from django.urls import include , path urlpatterns = [ path ( \"idom/\" , include ( \"django_idom.http.urls\" )), ... ]","title":"Configure urls.py"},{"location":"installation/#configure-asgipy","text":"Register IDOM's Websocket using IDOM_WEBSOCKET_PATH . asgi.py import os from django.core.asgi import get_asgi_application # Ensure DJANGO_SETTINGS_MODULE is set properly based on your project name! os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"example_project.settings\" ) django_asgi_app = get_asgi_application () from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from channels.sessions import SessionMiddlewareStack from django_idom import IDOM_WEBSOCKET_PATH application = ProtocolTypeRouter ( { \"http\" : django_asgi_app , \"websocket\" : SessionMiddlewareStack ( AuthMiddlewareStack ( URLRouter ([ IDOM_WEBSOCKET_PATH ])) ), } ) Where is my asgi.py? If you do not have an asgi.py , follow the channels installation guide .","title":"Configure asgi.py"}]}